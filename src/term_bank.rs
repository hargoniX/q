//! ## Term Bank
//! This module provides a term data structures as well as a term bank data structure in the spirit of
//! [E's term bank](https://wwwlehre.dhbw-stuttgart.de/~sschulz/PAPERS/Schulz-IWIL-2025.pdf).
//!
//! The key data structures are:
//! - [Term] which is a hash consed representation of first order terms with constant time
//!   comparison and hashing.
//! - [TermBank] which holds information about and can be used to create new hash consed terms

use std::{
    collections::HashSet,
    hash::{DefaultHasher, Hash, Hasher},
};

use crate::term_manager::{HashConsed, Table};

/// Describes a first order function.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FunctionInformation {
    /// The user visible name of the function, note that multiple functions with the same user name
    /// may exist within the same [TermBank].
    pub name: String,
    /// The arity of the function, in particular constants are encoded as 0-arity functions.
    pub arity: usize,
}

/// Describes a first order variable.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VariableInformation {
    /// The user visible name of the variable, note that multiple variables with the same user name
    /// may exist within the same [TermBank].
    pub name: String,
}

/// A unique function identifier generated by some [TermBank], can be used to query the
/// [FunctionInformation].
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct FunctionIdentifier(u32);

/// A unique variable identifier generated by some [TermBank], can be used to query the
/// [VariableInformation].
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct VariableIdentifier(u32);

/// All [Term] contain some pre computed values to speed up commonly done computations.
#[derive(Debug, PartialEq, Eq)]
pub struct TermData {
    hash: u64,
    var_bloom_filter: u64,
    var_count: u32,
    function_count: u32,
    weight: u32,
}

/// The raw term representation, this should *not* be used by consumers of this module, use [Term]
/// instead.
#[derive(Debug, PartialEq, Eq)]
pub enum RawTerm {
    Var {
        id: VariableIdentifier,
        data: TermData,
    },
    App {
        id: FunctionIdentifier,
        args: Vec<Term>,
        data: TermData,
    },
}

/// The general hash consed term representation.
pub type Term = HashConsed<RawTerm>;

impl Hash for RawTerm {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        state.write_u64(self.get_data().hash);
    }
}

impl VariableIdentifier {
    fn to_bloom_filter(&self) -> u64 {
        1 << (self.0 % 64) as u64
    }

    /// Check whether this identifier occurs in `term`. This check is `O(1)` if `term` is ground,
    /// for the general case its worse case `O(dag_size(term))`.
    pub fn occurs_in(&self, term: &Term) -> bool {
        let mut visited = HashSet::new();
        let mut worklist = vec![term];
        let bloom_id = self.to_bloom_filter();

        while let Some(term) = worklist.pop() {
            if term.get_data().var_bloom_filter & bloom_id == 0 || visited.contains(term) {
                continue;
            } else {
                match term.as_ref() {
                    RawTerm::Var { id, .. } => {
                        if id == self {
                            return true;
                        }
                    }
                    RawTerm::App { args, .. } => args.iter().for_each(|arg| {
                        worklist.push(arg);
                    }),
                }
                visited.insert(term);
            }
        }
        false
    }
}

impl RawTerm {
    /// Obtain the precomputed [TermData] associated with this term.
    fn get_data(&self) -> &TermData {
        match self {
            RawTerm::Var { data, .. } | RawTerm::App { data, .. } => data,
        }
    }

    /// `O(1)` check if  this term is ground.
    pub fn is_ground(&self) -> bool {
        self.get_data().var_bloom_filter == 0
    }

    /// Return `Some(x)` if the term is a variable, otherwise `None`.
    pub fn variable_id(&self) -> Option<VariableIdentifier> {
        match self {
            RawTerm::Var { id, .. } => Some(*id),
            RawTerm::App { .. } => None,
        }
    }

    /// Return `Some(f)` if the term is a function, otherwise `None`.
    pub fn function_id(&self) -> Option<FunctionIdentifier> {
        match self {
            RawTerm::Var { .. } => None,
            RawTerm::App { id, .. } => Some(*id),
        }
    }

    /// Return `Some([x1, x2, ...])` if the term is a function, otherwise `None`.
    pub fn function_args(&self) -> Option<&Vec<Term>> {
        match self {
            RawTerm::Var { .. } => None,
            RawTerm::App { args, .. } => Some(args),
        }
    }

    /// Obtain the precomuted default weight for the term for the clause queue.
    pub fn weight(&self) -> u32 {
        self.get_data().weight
    }

    /// Return `true` iff the term is a variable
    pub fn is_variable(&self) -> bool {
        match self {
            RawTerm::Var { .. } => true,
            _ => false,
        }
    }

    /// Return `true` iff the term is a function application (including constants)
    pub fn is_app(&self) -> bool {
        match self {
            RawTerm::App { .. } => true,
            _ => false,
        }
    }
}

impl HashConsed<RawTerm> {
    /// Accumulate all variables from this term into `acc`. This check is `O(1)` if the term is
    /// ground, for the general case its worse case `O(dag_size(self))`.
    pub fn collect_vars_into(&self, acc: &mut HashSet<VariableIdentifier>) {
        let mut visited = HashSet::new();
        let mut front = vec![self];
        while let Some(term) = front.pop() {
            match &**term {
                RawTerm::Var { id, .. } => {
                    acc.insert(*id);
                }
                RawTerm::App { args, .. } => {
                    for arg in args.iter() {
                        if !(arg.is_ground() && visited.contains(arg)) {
                            front.push(arg);
                        }
                        visited.insert(term);
                    }
                }
            }
        }
    }

    /// Accumulate all variables from this term into a hash set. This check is `O(1)` if the term is
    /// ground, for the general case its worse case `O(dag_size(self))`.
    pub fn collect_vars(&self) -> HashSet<VariableIdentifier> {
        let mut set = HashSet::new();
        self.collect_vars_into(&mut set);
        set
    }
}

/// The central data structure for generating new variables, registering new functions and
/// building terms. All terms generated by a term bank are perfectly shared.
#[derive(Debug)]
pub struct TermBank {
    hash_cons_table: Table<RawTerm>,
    variable_bank: Vec<VariableInformation>,
    function_bank: Vec<FunctionInformation>,
}

impl TermBank {
    /// Create a new empty term bank.
    pub fn new() -> Self {
        Self {
            hash_cons_table: Table::new(),
            variable_bank: Vec::new(),
            function_bank: Vec::new(),
        }
    }

    pub fn assert_names_unique(&self) {
        for my_idx in 0..self.variable_bank.len() {
            let my_info = &self.variable_bank[my_idx];
            for other_idx in (my_idx + 1)..self.variable_bank.len() {
                let other_info = &self.variable_bank[other_idx];
                debug_assert_ne!(my_info.name, other_info.name);
            }
        }

        for my_idx in 0..self.function_bank.len() {
            let my_info = &self.function_bank[my_idx];
            for other_idx in (my_idx + 1)..self.function_bank.len() {
                let other_info = &self.function_bank[other_idx];
                debug_assert_ne!(my_info.name, other_info.name);
            }
        }
    }

    /// Create a fresh variable with some associated information.
    pub fn add_variable(&mut self, info: VariableInformation) -> VariableIdentifier {
        let size = self.variable_bank.len();
        self.variable_bank.push(info);
        VariableIdentifier(size.try_into().unwrap())
    }

    /// Create a new function (or constant) with some associated information.
    pub fn add_function(&mut self, info: FunctionInformation) -> FunctionIdentifier {
        let size = self.function_bank.len();
        self.function_bank.push(info);
        FunctionIdentifier(size.try_into().unwrap())
    }

    /// Obtain the information that was initially associated with some variable identifier.
    pub fn get_variable_info(&self, id: VariableIdentifier) -> &VariableInformation {
        &self.variable_bank[id.0 as usize]
    }

    /// Obtain the information that was initially associated with some function identifier.
    pub fn get_function_info(&self, id: FunctionIdentifier) -> &FunctionInformation {
        &self.function_bank[id.0 as usize]
    }

    /// Perform gargabe collection on the underlying hash consing table to free up unused terms.
    pub fn gc(&self) {
        self.hash_cons_table.gc();
    }

    fn weight_heuristic(var_count: u32, function_count: u32) -> u32 {
        // This is E's clause queue term weight heuristic:
        // "standard weight (computed as two times function symbol count plus variable count)"
        2 * function_count + var_count
    }

    /// Create a hash consed variable term for some variable identifier.
    pub fn mk_variable(&self, id: VariableIdentifier) -> Term {
        let mut hasher = DefaultHasher::new();
        hasher.write_u32(id.0);
        let var = RawTerm::Var {
            id,
            data: TermData {
                hash: hasher.finish(),
                var_bloom_filter: id.to_bloom_filter(),
                var_count: 1,
                function_count: 0,
                weight: Self::weight_heuristic(1, 0),
            },
        };
        self.hash_cons_table.hashcons(var)
    }

    /// Generate a fresh variable identifier and return a hash consed term for it.
    pub fn mk_fresh_variable(&mut self, info: VariableInformation) -> Term {
        let id = self.add_variable(info);
        self.mk_variable(id)
    }

    pub(crate) fn mk_replacement_variable(&mut self, old_id: VariableIdentifier) -> Term {
        let mut info = self.get_variable_info(old_id).clone();
        let size = self.variable_bank.len();
        if info.name.ends_with("rep") {
            let foo = info.name.rsplit_once("_").unwrap().0;
            info.name = foo.to_owned() + &format!("_{}rep", size);
        } else {
            info.name.push_str(&format!("_{}rep", size));
        }
        self.mk_fresh_variable(info)
    }

    /// Generate a hash consed function application of some function identifier to some arguments.
    /// For constants use either [TermBank::mk_const] or pass the empty vector to `args`.
    pub fn mk_app(&self, id: FunctionIdentifier, args: Vec<Term>) -> Term {
        let mut hasher = DefaultHasher::new();
        hasher.write_u32(id.0);
        args.iter().for_each(|arg| arg.hash(&mut hasher));
        let hash = hasher.finish();
        let var_bloom_filter = args
            .iter()
            .fold(0, |acc, arg| acc | arg.get_data().var_bloom_filter);
        let var_count = args.iter().map(|a| a.get_data().var_count).sum();
        let function_count = args
            .iter()
            .map(|a| a.get_data().function_count)
            .sum::<u32>()
            + 1;
        assert_eq!(self.get_function_info(id).arity, args.len());
        let data = TermData {
            hash,
            var_bloom_filter,
            var_count,
            function_count,
            weight: Self::weight_heuristic(var_count, function_count),
        };
        let app = RawTerm::App { id, args, data };
        self.hash_cons_table.hashcons(app)
    }

    /// Generate a hash consed constant term.
    pub fn mk_const(&self, id: FunctionIdentifier) -> Term {
        self.mk_app(id, vec![])
    }

    /// Obtain the internal numerical identifier for some variable identifier, useful as an
    /// arbitrary variable to u32 mapping.
    pub fn get_variable_index(&self, ident: VariableIdentifier) -> u32 {
        ident.0
    }

    /// Obtain the internal numerical identifier for some function identifier, useful as an
    /// arbitrary function to u32 mapping.
    pub fn get_function_index(&self, ident: FunctionIdentifier) -> u32 {
        ident.0
    }

    /// Get the overall count of registered variables in the term bank.
    pub fn get_variable_count(&self) -> usize {
        self.variable_bank.len()
    }
}
